package ditto.parser;

import java_cup.runtime.*;
import ditto.lexer.Lexer;
import ditto.lexer.Token;
import ditto.errors.ErrorHandler;
import java.util.ArrayList;

import ditto.ast.*;
import ditto.ast.definitions.*;
import ditto.ast.designators.*;
import ditto.ast.expressions.*;
import ditto.ast.literals.*;
import ditto.ast.types.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private ErrorHandler errors;
   public void syntax_error(Symbol token) {
     errors.syntaxError((Token)token);
   }
:};
init with {: 
   errors = new ErrorHandler();
   Lexer lex = (Lexer)getScanner();
   lex.setErrorHandler(errors);
:};

/* PUNTUATION */
terminal PLUS, MINUS, TIMES, DIV, MOD, NOT_EQUAL, EQUAL, GREATER, LESS, GREATER_EQUAL, LESS_EQUAL,
         OPEN_PAR, CLOSE_PAR, OPEN_BRACKET, CLOSE_BRACKET,
         SEMICOLON, COMMA, DOT, QUADOT, AT, R_ARROW, ASSIGN;

/* KEYWORDS */
terminal AND, OR, NOT, FUNC, IF, ELSE, FOR, WHILE, IMPORT, RETURN, MATCH, CASE, IS, OTHERWISE, END, DO, THEN, MODULE, STRUCT, PUBLIC, FROM, TO, BY,
         PTR, REF, ARRAY, NEW;

/* LITERALS */
terminal Natural NAT;
terminal True   TRUE;
terminal False FALSE;
terminal String IDEN;

non terminal S;
non terminal ArrayList<Statement> STMTs;
non terminal Expr EXPR,
             DISJUNCTION, CONJUNCTION,
             NEGATION, EQUALITY, COMPARISON,
             TERM, FACTOR, UNARY, PRIMARY, FUNC_CALL,
             LITERAL, ARRAY_LITERAL;

non terminal Designator DESIGNATION;
non terminal ArrayList<Expr> EXPRs;

non terminal Statement STMT, ASSIGNMENT, IF_STMT, FOR_STMT, WHILE_STMT, MATCH_STMT, RETURN_STMT;

non terminal DefVar VAR_DECL;
non terminal DefFunc FUN_DECL;
non terminal DefStruct STRUCT_DECL;
non terminal MODULE_DECL;

non terminal Type TYPE;
non terminal ArrayList<String> NAME;
non terminal CASE_STMTs, LITERALs;
non terminal ArrayList<Param> FUNC_PARAMs, AT_LEAST_ONE_PARAM, NO_PARAM;
non terminal Param PARAM;
non terminal IMPORTs, DECLARATIONs, DECLARATION, DECLARATIONs_WITH_VISIBILITY, VISIBILITY;

/* Nuestro programa empieza con un conjunto de imports, y luego declaraciones */
S ::= IMPORTs DECLARATIONs;

IMPORTs ::= IMPORTs IMPORT NAME SEMICOLON | ;

DECLARATIONs ::= DECLARATIONs DECLARATION | ;
DECLARATION ::= STRUCT_DECL | MODULE_DECL | FUN_DECL | VAR_DECL;
DECLARATIONs_WITH_VISIBILITY ::= DECLARATIONs_WITH_VISIBILITY VISIBILITY DECLARATION | DECLARATION;
VISIBILITY ::= PUBLIC | ;

STRUCT_DECL ::= STRUCT IDEN IS DECLARATIONs END;

MODULE_DECL ::= MODULE IDEN IS DECLARATIONs_WITH_VISIBILITY END;

FUN_DECL    ::= FUNC IDEN:id OPEN_PAR FUNC_PARAMs:params CLOSE_PAR STMTs:statements END
               {: RESULT = new DefFunc(id, params, statements); :} | 
                FUNC IDEN:id OPEN_PAR FUNC_PARAMs:params CLOSE_PAR R_ARROW TYPE:type STMTs:statements END
               {: RESULT = new DefFunc(id, params, type, statements); :};
                
FUNC_PARAMs ::= AT_LEAST_ONE_PARAM | NO_PARAM;

AT_LEAST_ONE_PARAM ::= AT_LEAST_ONE_PARAM:params COMMA PARAM:p 
                     {: RESULT = params; params.add(p); :} | 
                     PARAM:p
                     {: RESULT = new ArrayList<Param>(); RESULT.add(p); :};

PARAM       ::= TYPE:t IDEN:id
               {: RESULT = new Param(t, id); :} | 
               REF TYPE:t IDEN:id
               {: RESULT = new Param(t, id, true); :};

NO_PARAM    ::= {: RESULT = new ArrayList<Param>(); :};

EXPR        ::= DISJUNCTION;
DISJUNCTION ::= DISJUNCTION OR CONJUNCTION | CONJUNCTION;
CONJUNCTION ::= CONJUNCTION AND NEGATION | NEGATION;
NEGATION    ::= NOT NEGATION | EQUALITY;
EQUALITY    ::= EQUALITY EQUAL COMPARISON | EQUALITY NOT_EQUAL COMPARISON | COMPARISON;
COMPARISON  ::= COMPARISON LESS TERM | COMPARISON GREATER TERM | COMPARISON LESS_EQUAL TERM | COMPARISON GREATER_EQUAL TERM | TERM;
TERM        ::= TERM PLUS FACTOR | TERM MINUS FACTOR | FACTOR;
FACTOR      ::= FACTOR TIMES UNARY | FACTOR DIV UNARY | FACTOR MOD UNARY | UNARY;
UNARY       ::= MINUS UNARY | PLUS UNARY | PTR UNARY | AT UNARY | PRIMARY;
PRIMARY     ::= LITERAL:e {: RESULT = e; :}
              | NEW LITERAL
              | DESIGNATION:d {: RESULT = d; :}
              | FUNC_CALL:x {: RESULT = x; :}
              | OPEN_PAR EXPR:e CLOSE_PAR {: RESULT = e; :};
FUNC_CALL   ::= DESIGNATION:d OPEN_PAR EXPRs:e CLOSE_PAR /* design(arg, ...) // Llamada con algún argumento */
               {: RESULT = new Call(d, e); :}
              | DESIGNATION OPEN_PAR CLOSE_PAR;      /* design()         // Llamada sin ningún argumento */
EXPRs       ::= EXPRs:more COMMA EXPR:e {: RESULT = more; more.add(e); :}
              | EXPR:e {: RESULT = new ArrayList<Expr>(); RESULT.add(e); :};

DESIGNATION ::= DESIGNATION:d OPEN_BRACKET EXPR:e CLOSE_BRACKET  /* design[expr]   */
             {: RESULT = new ArrayAccess(d, e); :}
              | DESIGNATION:d DOT IDEN:name                      /* design.iden()   */
             {: RESULT = new StructAccess(d, name); :}
              | DESIGNATION:d R_ARROW IDEN:name                         /* desig->iden    */
             {: RESULT = new StructAccess(new Deref(d), name); :}
              | NAME:name
             {: RESULT = new Var(name); :};                      /* Var should take a binding */                               
NAME        ::= NAME:more QUADOT IDEN:name                       /* name::iden */
             {: RESULT = more; more.add(name); :}
              | IDEN:name
             {: RESULT = new ArrayList<String>(); RESULT.add(name); :}; 

LITERAL     ::= NAT | TRUE | FALSE | ARRAY_LITERAL;
ARRAY_LITERAL ::= OPEN_BRACKET CLOSE_BRACKET                       /* [], empty array */
             {: RESULT = new ArrayLiteral(new ArrayList<Literal>()); :}
              |   OPEN_BRACKET LITERALs CLOSE_BRACKET              /* [ elem1, elem2, elem3, ..]*/
              |   OPEN_BRACKET LITERAL SEMICOLON NAT CLOSE_BRACKET; // [default; size]
LITERALs    ::= LITERALs COMMA LITERAL | LITERAL;

/* TODO: Quiza luego hay problema, porque estamos modificando la misma referencia de ArrayList */
STMTs       ::= STMTs:statements STMT:st {: RESULT = statements; statements.add(st); :}
               | {: RESULT = new ArrayList<Statement>(); :};

STMT        ::= EXPR SEMICOLON |
                ASSIGNMENT |
                VAR_DECL | // No ponemos funciones u otras declaraciones porque no las queremos en el cuerpo de una función
                IF_STMT |
                FOR_STMT |
                WHILE_STMT |
                MATCH_STMT |
                RETURN_STMT;

ASSIGNMENT  ::= DESIGNATION:name ASSIGN EXPR: e SEMICOLON 
             {: RESULT = new Assign(name, e); :};

VAR_DECL    ::= TYPE:t IDEN:name SEMICOLON
             {: RESULT = new DefVar(t, name); :}
              | TYPE ASSIGNMENT;
TYPE        ::= IDEN:name
             {: RESULT = new StructType(name); :} // By default, if it's not a primitive type, it's a struct. TODO: Link to the struct definition
              | PTR TYPE:t 
             {: RESULT = new PointerType(t); :}
              | ARRAY TYPE:t
             {: RESULT = new ArrayType(t); :}   // Esta descripción de tipo array solo se permite en argumentos de funciones A lo mejor si ponemos `array int a := [1,2]`, podemos "inferir" el tamaño de `a`con el tamaño del array literal */
              | ARRAY NAT:size TYPE:t           // TODO: Estudiar si es mejor otra sintaxis
             {: RESULT = new ArrayType(t, size); :};

IF_STMT     ::= IF EXPR:cond THEN STMTs:then END
               {: RESULT = new If(cond, then); :}
              | IF EXPR:cond THEN STMTs:then ELSE STMTs:els END
              {: RESULT = new If(cond, then, els); :};

FOR_STMT    ::= FOR IDEN:index FROM EXPR:from TO EXPR:to DO STMTs:statements END
               {: RESULT = new For(index, from, to, statements); :}
              | FOR IDEN:index FROM EXPR:from TO EXPR:to BY EXPR:by DO STMTs:statements END
              {: RESULT = new For(index, from, to, by, statements); :};

WHILE_STMT  ::= WHILE EXPR:cond DO STMTs:statements END
              {: RESULT = new While(cond, statements); :};

MATCH_STMT  ::= MATCH EXPR CASE_STMTs OTHERWISE STMTs END
              | MATCH EXPR CASE_STMTs END;
CASE_STMTs  ::= CASE EXPR IS STMTs CASE_STMTs | ;

RETURN_STMT ::= RETURN EXPR SEMICOLON;