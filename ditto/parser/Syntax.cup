package ditto.parser;

import java_cup.runtime.*;
import ditto.lexer.Lexer;
import ditto.lexer.Token;
import ditto.errors.ErrorHandler;
import java.util.List;
import java.util.ArrayList;


import ditto.ast.definitions.*;
import ditto.ast.designators.*;
import ditto.ast.expressions.*;
import ditto.ast.literals.*;
import ditto.ast.statements.*;
import ditto.ast.types.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private ErrorHandler errors;
   public void syntax_error(Symbol token) {
     errors.syntaxError((Token)token);
   }
:};
init with {: 
   errors = new ErrorHandler();
   Lexer lex = (Lexer)getScanner();
   lex.setErrorHandler(errors);
:};

/* PUNTUATION */
terminal PLUS, MINUS, TIMES, DIV, MOD, NOT_EQUAL, EQUAL, GREATER, LESS, GREATER_EQUAL, LESS_EQUAL,
         OPEN_PAR, CLOSE_PAR, OPEN_BRACKET, CLOSE_BRACKET,
         SEMICOLON, COMMA, DOT, QUADOT, AT, R_ARROW, ASSIGN;

/* KEYWORDS */
terminal AND, OR, NOT, FUNC, IF, ELSE, FOR, WHILE, IMPORT, RETURN, MATCH, CASE, IS, OTHERWISE, END, DO, THEN, MODULE, STRUCT, PUBLIC, FROM, TO, BY,
         PTR, REF, ARRAY, NEW;

/* LITERALS */
terminal Natural NAT;
terminal True   TRUE;
terminal False FALSE;
terminal String IDEN;

non terminal S;
non terminal ArrayList<Statement> STMTs;

non terminal Expr EXPR, PRIMARY;
non terminal Expr DISJUNCTION, CONJUNCTION, EQUALITY, COMPARISON, TERM, FACTOR;
non terminal Expr NEGATION, UNARY;

non terminal ArrayLiteral ARRAY_LITERAL;
non terminal Call FUNC_CALL;

non terminal Literal LITERAL;
non terminal Designator DESIGNATION;
non terminal List<Expr> EXPRs;

non terminal Statement STMT, ASSIGNMENT, IF_STMT, FOR_STMT, WHILE_STMT, MATCH_STMT, RETURN_STMT;

non terminal DefVar VAR_DECL;
non terminal DefFunc FUN_DECL;
non terminal DefStruct STRUCT_DECL;
non terminal MODULE_DECL;

non terminal Type TYPE;
non terminal List<String> NAME;
non terminal CASE_STMTs;
non terminal List<Literal> LITERALs;
non terminal List<Param> FUNC_PARAMs, AT_LEAST_ONE_PARAM, NO_PARAM;
non terminal Param PARAM;
non terminal IMPORTs, DECLARATIONs, DECLARATION, DECLARATIONs_WITH_VISIBILITY, VISIBILITY;

/* Nuestro programa empieza con un conjunto de imports, y luego declaraciones */
S ::= IMPORTs DECLARATIONs;

IMPORTs ::= IMPORTs IMPORT NAME SEMICOLON | ;

DECLARATIONs ::= DECLARATIONs DECLARATION | ;
DECLARATION ::= STRUCT_DECL | MODULE_DECL | FUN_DECL | VAR_DECL;
DECLARATIONs_WITH_VISIBILITY ::= DECLARATIONs_WITH_VISIBILITY VISIBILITY DECLARATION | DECLARATION;
VISIBILITY ::= PUBLIC | ;

STRUCT_DECL ::= STRUCT IDEN IS DECLARATIONs END;

MODULE_DECL ::= MODULE IDEN IS DECLARATIONs_WITH_VISIBILITY END;

FUN_DECL    ::= FUNC IDEN:id OPEN_PAR FUNC_PARAMs:params CLOSE_PAR STMTs:statements END
               {: RESULT = new DefFunc(id, params, statements); :} | 
                FUNC IDEN:id OPEN_PAR FUNC_PARAMs:params CLOSE_PAR R_ARROW TYPE:type STMTs:statements END
               {: RESULT = new DefFunc(id, params, type, statements); :};
                
// Suponemos que como todas las ramas dan lugar a un solo no terminal, que tomará el valor de ese no terminal
FUNC_PARAMs ::= AT_LEAST_ONE_PARAM:l {: RESULT = l; :}
              | NO_PARAM:l {: RESULT = l; :};

AT_LEAST_ONE_PARAM ::= AT_LEAST_ONE_PARAM:params COMMA PARAM:p 
                     {: RESULT = params; params.add(p); :} | 
                     PARAM:p
                     {: RESULT = new ArrayList<Param>(); RESULT.add(p); :};

PARAM       ::= TYPE:t IDEN:id                      /*Por valor*/
               {: RESULT = new Param(t, id); :} | 
               REF TYPE:t IDEN:id                   /*Por referencia*/
               {: RESULT = new Param(t, id, true); :};

NO_PARAM    ::= {: RESULT = new ArrayList<Param>(); :};

EXPR        ::= DISJUNCTION:d {: RESULT = d; :};
DISJUNCTION ::= DISJUNCTION:left OR CONJUNCTION:rigth 
                {: RESULT =  new OperBin(OperBin.Operators.OR, left, rigth); :}
              | CONJUNCTION:expr 
                {: RESULT = expr; :};
CONJUNCTION ::= CONJUNCTION:left AND NEGATION:rigth
                {: RESULT = new OperBin(OperBin.Operators.AND, left, rigth); :}
              | NEGATION:expr 
                {: RESULT = expr; :};
NEGATION    ::= NOT NEGATION:expr
                {: RESULT = new OperUn(OperUn.Operators.NOT, expr); :}
              | EQUALITY:expr  
                {: RESULT = expr; :};
EQUALITY    ::= EQUALITY:left EQUAL COMPARISON:rigth 
                {: RESULT = new OperBin(OperBin.Operators.EQUALS, left, rigth); :}
              | EQUALITY:left NOT_EQUAL COMPARISON:rigth 
                {: RESULT = new OperBin(OperBin.Operators.NOTEQUALS, left, rigth); :}
              | COMPARISON:expr 
                {: RESULT = expr; :};
COMPARISON  ::= COMPARISON:left LESS TERM:rigth
                {: RESULT =  new OperBin(OperBin.Operators.LESS, left, rigth); :}
              | COMPARISON:left GREATER TERM:rigth
                {: RESULT = new OperBin(OperBin.Operators.GREATER, left, rigth); :} 
              | COMPARISON:left LESS_EQUAL TERM:rigth
                {: RESULT = new OperBin(OperBin.Operators.LESS_EQUAL, left, rigth); :} 
              | COMPARISON:left GREATER_EQUAL TERM:rigth
                {: RESULT = new OperBin(OperBin.Operators.GREATER_EQUAL, left, rigth); :} 
              | TERM:expr
                {: RESULT = expr; :};
TERM        ::= TERM:left PLUS FACTOR:rigth
                {: RESULT =  new OperBin(OperBin.Operators.SUM, left, rigth); :}
              | TERM:left MINUS FACTOR:rigth
                {: RESULT = new OperBin(OperBin.Operators.SUBS, left, rigth); :} 
              | FACTOR:expr
                {: RESULT = expr; :};
FACTOR      ::= FACTOR:left TIMES UNARY:rigth
                {: RESULT = new OperBin(OperBin.Operators.MUL, left, rigth); :}
              | FACTOR:left DIV UNARY:rigth 
                {: RESULT = new OperBin(OperBin.Operators.DIV, left, rigth); :}
              | FACTOR:left MOD UNARY:rigth
                {: RESULT = new OperBin(OperBin.Operators.MODULO, left, rigth); :} 
              | UNARY:expr
                {: RESULT = expr; :};
UNARY       ::= MINUS UNARY:expr
                {: RESULT = new OperUn(OperUn.Operators.NEG, expr); :}
              | PLUS UNARY:expr 
                {: RESULT = expr; :}
              | PTR UNARY:expr
                {: RESULT = new OperUn(OperUn.Operators.REF, expr); :}
              | AT UNARY:expr
                {: RESULT = new OperUn(OperUn.Operators.DEREF, expr); :}
              | PRIMARY:expr
                {: RESULT = expr; :};
PRIMARY     ::= LITERAL:e {: RESULT = e; :}
              //| NEW LITERAL:expr
              //{: RESULT = new OperUn(OperUn.Operators.NEW, expr); :}
              | DESIGNATION:d {: RESULT = (Expr) d; :}
              | FUNC_CALL:x {: RESULT = (Expr) x; :}
              | OPEN_PAR EXPR:e CLOSE_PAR {: RESULT = (Expr) e; :};
FUNC_CALL   ::= DESIGNATION:d OPEN_PAR EXPRs:e CLOSE_PAR /* design(arg, ...) // Llamada con algún argumento */
               {: RESULT = new Call(d, e); :}
              | DESIGNATION OPEN_PAR CLOSE_PAR;      /* design()         // Llamada sin ningún argumento */
EXPRs       ::= EXPRs:more COMMA EXPR:e {: RESULT = more; more.add((Expr) e); :}
              | EXPR:e {: RESULT = new ArrayList<Expr>(); RESULT.add((Expr) e); :};

/*
Literales
int    → 10, 1, 30
bool   → true, false
array  → [10; 1], [1,2,3,4]
ptr    → NO TIENE (@a)
struct → Persona{edad: 20}

(new Persona{edad: 20})->edad // Ugly

self.setNext(new Persona{edad: 20});
self.next.prev = self;

new Persona{edad: 20};
new [Persona{}; 10];
new true;
new 10;

*/


DESIGNATION ::= DESIGNATION:d OPEN_BRACKET EXPR:e CLOSE_BRACKET  /* design[expr]   */
             {: RESULT = new ArrayAccess(d, e); :}
              | DESIGNATION:d DOT IDEN:name                      /* design.iden()   */
             {: RESULT = new StructAccess(d, name); :}
              | DESIGNATION:d R_ARROW IDEN:name                         /* desig->iden    */
             {: RESULT = new StructAccess(new Deref(d), name); :}
              | NAME:name
             {: RESULT = new Var(name); :};                      /* Var should take a binding */                               
NAME        ::= NAME:more QUADOT IDEN:name                       /* name::iden */
             {: RESULT = more; more.add(name); :}
              | IDEN:name
             {: RESULT = new ArrayList<String>(); RESULT.add(name); :}; 

LITERAL     ::= NAT:n           {: RESULT = n; :}
              | TRUE:t          {: RESULT = t; :}
              | FALSE:f         {: RESULT = f; :}
              | ARRAY_LITERAL:a {: RESULT = a; :};
LITERALs    ::= LITERALs:more COMMA LITERAL:l {: RESULT = more; more.add(l); :}
              | LITERAL:l {: RESULT = new ArrayList<Literal>(); RESULT.add(l); :};
ARRAY_LITERAL ::= OPEN_BRACKET CLOSE_BRACKET        
             {: RESULT = new ArrayLiteral(new ArrayList<Literal>()); :}  /* [] // empty array */
              |   OPEN_BRACKET LITERALs:ls CLOSE_BRACKET              
             {: RESULT = new ArrayLiteral(ls); :}                        /* [elem1, elem2, elem3, ...]*/
              |   OPEN_BRACKET LITERAL:def SEMICOLON NAT:size CLOSE_BRACKET 
             {: RESULT = new ArrayLiteral(def,size); :};             /* [default; size] */

/* TODO: Quiza luego hay problema, porque estamos modificando la misma referencia de ArrayList */
STMTs       ::= STMTs:statements STMT:st {: RESULT = statements; statements.add(st); :}
           | {: RESULT = new ArrayList<Statement>(); :};

STMT        ::= EXPR SEMICOLON 
              | ASSIGNMENT
              | VAR_DECL     // No ponemos funciones u otras declaraciones porque no las queremos en el cuerpo de una función
              | IF_STMT
              | FOR_STMT
              | WHILE_STMT
              | MATCH_STMT
              | RETURN_STMT;

ASSIGNMENT  ::= DESIGNATION:name ASSIGN EXPR: e SEMICOLON 
             {: RESULT = new Assign(name, e); :};

VAR_DECL    ::= TYPE:t IDEN:name SEMICOLON
             {: RESULT = new DefVar(t, name); :}
              | TYPE ASSIGNMENT;
TYPE        ::= IDEN:name
             {: RESULT = new StructType(name); :} // By default, if it's not a primitive type, it's a struct. TODO: Link to the struct definition
              | PTR TYPE:t 
             {: RESULT = new PointerType(t); :}
              | ARRAY TYPE:t
             {: RESULT = new ArrayType(t); :}   // Esta descripción de tipo array solo se permite en argumentos de funciones A lo mejor si ponemos `array int a := [1,2]`, podemos "inferir" el tamaño de `a`con el tamaño del array literal */
              | ARRAY NAT:size TYPE:t           // TODO: Estudiar si es mejor otra sintaxis
             {: RESULT = new ArrayType(t, size); :};

IF_STMT     ::= IF EXPR:cond THEN STMTs:then END
               {: RESULT = new If(cond, then); :}
              | IF EXPR:cond THEN STMTs:then ELSE STMTs:els END
              {: RESULT = new If(cond, then, els); :};

FOR_STMT    ::= FOR IDEN:index FROM EXPR:from TO EXPR:to DO STMTs:statements END
               {: RESULT = new For(index, from, to, statements); :}
              | FOR IDEN:index FROM EXPR:from TO EXPR:to BY EXPR:by DO STMTs:statements END
              {: RESULT = new For(index, from, to, by, statements); :};

WHILE_STMT  ::= WHILE EXPR:cond DO STMTs:statements END
              {: RESULT = new While(cond, statements); :};

MATCH_STMT  ::= MATCH EXPR CASE_STMTs OTHERWISE STMTs END
              | MATCH EXPR CASE_STMTs END;
CASE_STMTs  ::= CASE EXPR IS STMTs CASE_STMTs | ;

RETURN_STMT ::= RETURN EXPR SEMICOLON;