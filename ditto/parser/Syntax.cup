package ditto.parser;

import java_cup.runtime.*;
import ditto.lexer.Lexer;
import ditto.lexer.Token;
import ditto.errors.ErrorHandler;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private ErrorHandler errors;
   public void syntax_error(Symbol token) {
     errors.syntaxError((Token)token);
   }
:};
init with {: 
   errors = new ErrorHandler();
   Lexer lex = (Lexer)getScanner();
   lex.setErrorHandler(errors);
:};

terminal PLUS, MINUS, TIMES, DIV, MOD, LESS, GREATER, NOT_EQUAL, EQUAL,
         GREATER_EQUAL, LESS_EQUAL, AND, OR, NOT, OPEN_PAR, CLOSE_PAR;

terminal NAT;
terminal TRUE, FALSE;
terminal IDEN, ASSIGN, FUNC, IF, ELSE, FOR, WHILE, IMPORT, RETURN, MATCH, CASE, IS, SEMICOLON, COMMA, QUADOT,
         OPEN_BRACKET, CLOSE_BRACKET, R_ARROW, OTHERWISE, END, DO, THEN, MODULE, STRUCT, PUBLIC, FROM, TO, BY,
         PTR, REF, ARRAY, NEW, DOT, AT;

non terminal S, EXPR, STMTs;
non terminal DISJUNCTION, CONJUNCTION;
non terminal NEGATION, EQUALITY, COMPARISON;
non terminal TERM, FACTOR, UNARY, ACCESS, PRIMARY, FUNC_CALL;
non terminal STMT, ASSIGNMENT, IF_STMT, FOR_STMT, WHILE_STMT, MATCH_STMT, RETURN_STMT, NEW_STMT;
non terminal VAR_DECL, FUN_DECL, STRUCT_DECL, MODULE_DECL;
non terminal TYPE, NAME, LITERAL, ARRAY_LITERAL;
non terminal CASE_STMTs, EXPRs;
non terminal FUNC_PARAMs, AT_LEAST_ONE_PARAM, NO_PARAM, PARAM;
non terminal IMPORTs, DECLARATIONs, DECLARATION, DECLARATIONs_WITH_VISIBILITY, VISIBILITY;
non terminal NATs, VAR_OR_FUNC_CALL;

S ::= IMPORTs DECLARATIONs;

IMPORTs ::= IMPORTs IMPORT NAME SEMICOLON | ;
DECLARATIONs ::= DECLARATIONs DECLARATION | ;
DECLARATION ::= STRUCT_DECL | MODULE_DECL | FUN_DECL | VAR_DECL;
DECLARATIONs_WITH_VISIBILITY ::= DECLARATIONs_WITH_VISIBILITY VISIBILITY DECLARATION | DECLARATION;
VISIBILITY ::= PUBLIC | ;

STRUCT_DECL ::= STRUCT IDEN IS DECLARATIONs END;

MODULE_DECL ::= MODULE IDEN IS DECLARATIONs_WITH_VISIBILITY END;

FUN_DECL    ::= FUNC IDEN OPEN_PAR FUNC_PARAMs CLOSE_PAR STMTs END |
                FUNC IDEN OPEN_PAR FUNC_PARAMs CLOSE_PAR R_ARROW TYPE STMTs END;
FUNC_PARAMs ::= AT_LEAST_ONE_PARAM | NO_PARAM;
AT_LEAST_ONE_PARAM ::= AT_LEAST_ONE_PARAM COMMA PARAM | PARAM;
PARAM       ::= TYPE IDEN | REF TYPE IDEN;
NO_PARAM    ::= ;

EXPR        ::= DISJUNCTION;
DISJUNCTION ::= DISJUNCTION OR CONJUNCTION | CONJUNCTION;
CONJUNCTION ::= CONJUNCTION AND NEGATION | NEGATION;
NEGATION    ::= NOT NEGATION | EQUALITY;
EQUALITY    ::= EQUALITY EQUAL COMPARISON | EQUALITY NOT_EQUAL COMPARISON | COMPARISON;
COMPARISON  ::= COMPARISON LESS TERM | COMPARISON GREATER TERM | COMPARISON LESS_EQUAL TERM | COMPARISON GREATER_EQUAL TERM | TERM;
TERM        ::= TERM PLUS FACTOR | TERM MINUS FACTOR | FACTOR;
FACTOR      ::= FACTOR TIMES UNARY | FACTOR DIV UNARY | FACTOR MOD UNARY | UNARY;
UNARY       ::= MINUS UNARY | PLUS UNARY | PTR UNARY | AT UNARY | ACCESS;
ACCESS      ::= ACCESS OPEN_BRACKET EXPR CLOSE_BRACKET | ACCESS DOT VAR_OR_FUNC_CALL | ACCESS R_ARROW VAR_OR_FUNC_CALL | PRIMARY;
PRIMARY     ::= LITERAL | NEW LITERAL | NAME | FUNC_CALL | OPEN_PAR EXPR CLOSE_PAR;
FUNC_CALL   ::= NAME OPEN_PAR EXPRs CLOSE_PAR;
EXPRs       ::= EXPRs COMMA EXPR | EXPR;

VAR_OR_FUNC_CALL ::= IDEN | FUNC_CALL;

NAME        ::= NAME QUADOT IDEN | IDEN;

LITERAL     ::= NAT | TRUE | FALSE | ARRAY_LITERAL;
ARRAY_LITERAL ::= OPEN_BRACKET CLOSE_BRACKET |                  /* [], empty array */
                  OPEN_BRACKET NATs CLOSE_BRACKET |             /* [ elem1, elem2, elem3, ..]*/
                  OPEN_BRACKET NAT SEMICOLON NAT CLOSE_BRACKET; // [default; size]
NATs        ::= NATs COMMA NAT | NAT;

STMTs       ::= STMTs STMT | ;
STMT        ::= EXPR SEMICOLON |
                ASSIGNMENT |
                VAR_DECL | // No ponemos funciones u otras declaraciones porque no las queremos en el cuerpo de una funci√≥n
                IF_STMT |
                FOR_STMT |
                WHILE_STMT |
                MATCH_STMT |
                RETURN_STMT;

ASSIGNMENT  ::= IDEN ASSIGN EXPR SEMICOLON;

VAR_DECL    ::= TYPE IDEN SEMICOLON | 
                TYPE ASSIGNMENT;
TYPE        ::= IDEN | PTR TYPE | ARRAY TYPE;

IF_STMT     ::= IF EXPR THEN STMTs END |
                IF EXPR THEN STMTs ELSE STMTs END;

FOR_STMT    ::= FOR IDEN FROM EXPR TO EXPR DO STMTs END |
                FOR IDEN FROM EXPR TO EXPR BY EXPR DO STMTs END;

WHILE_STMT  ::= WHILE EXPR DO STMTs END;

MATCH_STMT  ::= MATCH EXPR CASE_STMTs OTHERWISE STMTs END |
                MATCH EXPR CASE_STMTs END;
CASE_STMTs  ::= CASE EXPR IS STMTs CASE_STMTs | ;

RETURN_STMT ::= RETURN EXPR SEMICOLON;
